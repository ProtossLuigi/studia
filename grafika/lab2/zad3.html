<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>zad3</title>
</head>
<body>
<canvas id="mainCanvas" width="1000" height="1000"></canvas>
<script id="vertexSource" type="notjs">
    uniform float depth;
    uniform vec2 offset;
    attribute vec2 coordinates;
    void main(){
        gl_Position = vec4(coordinates + offset, depth, 1.0);
        gl_PointSize = 1.0;
    }
</script>
<script id="fragmentSource" type="notjs">
    void main(){
        gl_FragColor = vec4(1.0,1.0,1.0,1.0);
    }
</script>
<script>
    let canvas = document.getElementById("mainCanvas");
    let gl = canvas.getContext("webgl");
    let platformWidth = 0.4;
    let platformHeight = 0.05;
    let playerPos = 0.0;
    let opponentPos = 0.0;
    let ballSize = 0.05;
    let playerMaxSpeed = 0.002;
    let playerCurrentSpeed = 0.0;
    let ballPos = [0.0,0.0];
    let ballCurrentSpeed = [0.0,0.0];
    let ballMaxSpeed = 0.002;
    let lastTime;
    let frameId = 0;
    let playerScore = 0;
    let CPUScore = 0;

    let ballCoordBuffer;
    let platformCoordBuffer;

    let depthLoc;
    let offsetLoc;
    let coordLoc;

    function createShader(type, source) {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader;
        }

        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }

    function createProgram(vertexShader, fragmentShader) {
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        let success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
            return program;
        }

        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    }

    function draw() {
        //console.log("got to draw");
        gl.clearColor(0.0,0.0,0.0,1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(depthLoc,0.0);
        gl.uniform2fv(offsetLoc,ballPos);
        gl.bindBuffer(gl.ARRAY_BUFFER,ballCoordBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.uniform2fv(offsetLoc,[-1.0+platformHeight/2,playerPos]);
        gl.bindBuffer(gl.ARRAY_BUFFER,platformCoordBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.uniform2fv(offsetLoc,[1.0-platformHeight/2,opponentPos]);
        gl.bindBuffer(gl.ARRAY_BUFFER,platformCoordBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.bindBuffer(gl.ARRAY_BUFFER,null);
    }

    function animate(time) {
        let timeDelta = time - lastTime;
        lastTime = time;
        playerPos += playerCurrentSpeed * timeDelta;
        if (playerPos > 1.0-platformWidth/2){
            playerPos = 1.0-platformWidth/2;
            playerCurrentSpeed = 0.0;
        } else if (playerPos < -1.0+platformWidth/2){
            playerPos = -1.0+platformWidth/2;
            playerCurrentSpeed = 0.0;
        }
        ballPos[0] += ballCurrentSpeed[0] * timeDelta;
        ballPos[1] += ballCurrentSpeed[1] * timeDelta;
        if (ballPos[0]-ballSize/2 < platformHeight-1.0 && (Math.abs(ballPos[1]-playerPos) < (platformWidth+ballSize)/2)){
            ballCurrentSpeed[0] *= -1;
            ballPos[0] = -2.0+platformHeight*2-ballPos[0];
        }
        if (ballPos[0]+ballSize/2 > -platformHeight+1.0 && (Math.abs(ballPos[1]-opponentPos) < (platformWidth+ballSize)/2)){
            ballCurrentSpeed[0] *= -1;
            ballPos[0] = 2.0-platformHeight*2-ballPos[0];
        }
        if (ballPos[1] < -1.0){
            ballCurrentSpeed[1] *= -1;
            ballPos[1] = -2.0-ballPos[1];
        }
        if (ballPos[1] > 1.0){
            ballCurrentSpeed[1] *= -1;
            ballPos[1] = 2.0-ballPos[1];
        }
        draw();
        gl.finish();
        frameId = window.requestAnimationFrame(animate);
        if (ballPos[0]-ballSize/2 < -1.0){
            CPUScore++;
            resetGame();
        }
        if (ballPos[0]+ballSize/2 > 1.0){
            playerScore++;
            resetGame();
        }
    }

    function startGame() {
        let angle = Math.random()*Math.PI*2;
        ballCurrentSpeed = [Math.cos(angle)*ballMaxSpeed, Math.sin(angle)*ballMaxSpeed];
        lastTime = window.performance.now();
        frameId = window.requestAnimationFrame(animate);
    }

    function resetGame() {
        console.log("it reset");
        if (frameId !== 0) window.cancelAnimationFrame(frameId);
        frameId = 0;
        playerPos = 0.0;
        playerCurrentSpeed = 0.0;
        opponentPos = 0.0;
        ballPos = [0.0,0.0];
        ballCurrentSpeed = [0.0,0.0];
        draw();
    }
    
    function onKeyDown(e) {
        switch (e.code) {
            case "ArrowUp":
                playerCurrentSpeed = playerMaxSpeed;
                if (frameId === 0) startGame();
                break;
            case "ArrowDown":
                playerCurrentSpeed = -playerMaxSpeed;
                if (frameId === 0) startGame();
                break;
            default:
                return;
        }
    }

    function onKeyUp(e) {
        switch (e.code) {
            case "ArrowUp":
            case "ArrowDown":
                playerCurrentSpeed = 0.0;
                break;
            default:
                return;
        }
    }

    function init() {
        let vSource = document.getElementById("vertexSource").text;
        let fSource = document.getElementById("fragmentSource").text;
        let vertexShader = createShader(gl.VERTEX_SHADER,vSource);
        let fragmentShader = createShader(gl.FRAGMENT_SHADER,fSource);
        let program = createProgram(vertexShader,fragmentShader);
        gl.useProgram(program);
        depthLoc = gl.getUniformLocation(program,"depth");
        offsetLoc = gl.getUniformLocation(program,"offset");
        coordLoc = gl.getAttribLocation(program,"coordinates");
        gl.enableVertexAttribArray(coordLoc);
        ballCoordBuffer = gl.createBuffer();
        platformCoordBuffer = gl.createBuffer();
        gl.clearColor(0.0,0.0,0.0,1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        gl.viewport(0,0,canvas.width,canvas.height);

        let platformCoords = [
            platformHeight/2,platformWidth/2,
            -platformHeight/2,platformWidth/2,
            platformHeight/2,-platformWidth/2,
            -platformHeight/2,-platformWidth/2
        ];
        gl.bindBuffer(gl.ARRAY_BUFFER,platformCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(platformCoords),gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER,ballCoordBuffer);
        let ballCoords = [
            ballSize/2,ballSize/2,
            ballSize/2,-ballSize/2,
            -ballSize/2,ballSize/2,
            -ballSize/2,-ballSize/2
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(ballCoords),gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER,null);

        draw();

        window.onkeydown = onKeyDown;
        window.onkeyup = onKeyUp;
    }

    window.onload = init;
</script>
</body>
</html>