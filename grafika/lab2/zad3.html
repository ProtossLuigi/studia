<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>zad3</title>
</head>
<body>
<canvas id="mainCanvas" width="1000" height="1000"></canvas>
<script id="vertexSource" type="notjs">
    uniform float depth;
    uniform vec2 offset;
    attribute vec2 coordinates;
    void main(){
        gl_Position = vec4(coordinates + offset, depth, 1.0);
        gl_PointSize = 1.0;
    }
</script>
<script id="fragmentSource" type="notjs">
    uniform lowp vec3 color;
    uniform lowp float alpha;
    void main(){
        gl_FragColor = vec4(color,alpha);
    }
</script>
<script>
    let canvas = document.getElementById("mainCanvas");
    let gl = canvas.getContext("webgl");
    let platformWidth = 0.4;
    let platformHeight = 0.05;
    let playerPos = 0.0;
    let opponentPos = 0.0;
    let ballSize = 0.05;
    let playerMaxSpeed = 0.002;
    let playerCurrentSpeed = 0.0;
    let ballPos = [0.0,0.0];
    let ballCurrentSpeed = [0.0,0.0];
    let ballMaxSpeed = 0.002;
    let lastTime;
    let frameId = 0;
    let playerScore = 0;
    let CPUScore = 0;
    let numberWidth = 0.45;
    let numberHeight = 0.75;
    let midlineWidth = 0.05;
    let numberMargin = 0.15;

    let ballCoordBuffer;
    let platformCoordBuffer;
    let midlineBuffer;

    let zero = {};
    let one = {};
    let two = {};
    let three = {};
    let four = {};
    let five = {};
    let six = {};
    let seven = {};
    let eight = {};
    let nine = {};

    let depthLoc;
    let offsetLoc;
    let coordLoc;
    let colorLoc;
    let alphaLoc;

    function createShader(type, source) {
        let shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
            return shader;
        }

        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
    }

    function createProgram(vertexShader, fragmentShader) {
        let program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        let success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
            return program;
        }

        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
    }

    function draw() {
        //console.log("got to draw");
        gl.clearColor(0.0,0.0,0.0,1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform3fv(colorLoc,[0.1,0.1,0.1]);
        gl.uniform1f(depthLoc,0.5);
        gl.uniform1f(alphaLoc,0.5);
        gl.uniform2fv(offsetLoc,[0.0,0.0]);
        gl.bindBuffer(gl.ARRAY_BUFFER,midlineBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        let number;
        switch (playerScore%5) {
            case 0:
                number = zero;
                break;
            case 1:
                number = one;
                break;
            case 2:
                number = two;
                break;
            case 3:
                number = three;
                break;
            case 4:
                number = four;
                break;
        }
        gl.uniform2fv(offsetLoc,[-numberWidth-numberMargin,-numberHeight/2]);
        gl.bindBuffer(gl.ARRAY_BUFFER,number.buffer);
        gl.vertexAttribPointer(colorLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,number.length);

        switch (CPUScore%5) {
            case 0:
                number = zero;
                break;
            case 1:
                number = one;
                break;
            case 2:
                number = two;
                break;
            case 3:
                number = three;
                break;
            case 4:
                number = four;
                break;
        }
        gl.uniform2fv(offsetLoc,[numberMargin,-numberHeight/2]);
        gl.bindBuffer(gl.ARRAY_BUFFER,number.buffer);
        gl.vertexAttribPointer(colorLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,number.length);

        gl.uniform1f(depthLoc,0.0);
        gl.uniform3fv(colorLoc,[1.0,1.0,1.0]);
        gl.uniform1f(alphaLoc,1.0);
        gl.uniform2fv(offsetLoc,ballPos);
        gl.bindBuffer(gl.ARRAY_BUFFER,ballCoordBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.uniform2fv(offsetLoc,[-1.0+platformHeight/2,playerPos]);
        gl.bindBuffer(gl.ARRAY_BUFFER,platformCoordBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.uniform2fv(offsetLoc,[1.0-platformHeight/2,opponentPos]);
        gl.bindBuffer(gl.ARRAY_BUFFER,platformCoordBuffer);
        gl.vertexAttribPointer(coordLoc,2,gl.FLOAT,false,0,0);
        gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

        gl.bindBuffer(gl.ARRAY_BUFFER,null);
    }

    function animate(time) {
        let timeDelta = time - lastTime;
        lastTime = time;
        playerPos += playerCurrentSpeed * timeDelta;
        if (playerPos > 1.0-platformWidth/2){
            playerPos = 1.0-platformWidth/2;
            playerCurrentSpeed = 0.0;
        } else if (playerPos < -1.0+platformWidth/2){
            playerPos = -1.0+platformWidth/2;
            playerCurrentSpeed = 0.0;
        }
        ballPos[0] += ballCurrentSpeed[0] * timeDelta;
        ballPos[1] += ballCurrentSpeed[1] * timeDelta;
        if (ballPos[0]-ballSize/2 < platformHeight-1.0 && (Math.abs(ballPos[1]-playerPos) < (platformWidth+ballSize)/2)){
            ballCurrentSpeed[0] *= -1;
            ballPos[0] = -2.0+platformHeight*2-ballPos[0];
        }
        if (ballPos[0]+ballSize/2 > -platformHeight+1.0 && (Math.abs(ballPos[1]-opponentPos) < (platformWidth+ballSize)/2)){
            ballCurrentSpeed[0] *= -1;
            ballPos[0] = 2.0-platformHeight*2-ballPos[0];
        }
        if (ballPos[1] < -1.0){
            ballCurrentSpeed[1] *= -1;
            ballPos[1] = -2.0-ballPos[1];
        }
        if (ballPos[1] > 1.0){
            ballCurrentSpeed[1] *= -1;
            ballPos[1] = 2.0-ballPos[1];
        }
        draw();
        gl.finish();
        frameId = window.requestAnimationFrame(animate);
        if (ballPos[0]-ballSize/2 < -1.0){
            CPUScore++;
            resetGame();
        }
        if (ballPos[0]+ballSize/2 > 1.0){
            playerScore++;
            resetGame();
        }
    }

    function startGame() {
        let angle = Math.random()*Math.PI*2;
        ballCurrentSpeed = [Math.cos(angle)*ballMaxSpeed, Math.sin(angle)*ballMaxSpeed];
        lastTime = window.performance.now();
        frameId = window.requestAnimationFrame(animate);
    }

    function resetGame() {
        console.log("it reset");
        if (frameId !== 0) window.cancelAnimationFrame(frameId);
        frameId = 0;
        playerPos = 0.0;
        playerCurrentSpeed = 0.0;
        opponentPos = 0.0;
        ballPos = [0.0,0.0];
        ballCurrentSpeed = [0.0,0.0];
        draw();
    }
    
    function onKeyDown(e) {
        switch (e.code) {
            case "ArrowUp":
                playerCurrentSpeed = playerMaxSpeed;
                if (frameId === 0) startGame();
                break;
            case "ArrowDown":
                playerCurrentSpeed = -playerMaxSpeed;
                if (frameId === 0) startGame();
                break;
            default:
                return;
        }
    }

    function onKeyUp(e) {
        switch (e.code) {
            case "ArrowUp":
            case "ArrowDown":
                playerCurrentSpeed = 0.0;
                break;
            default:
                return;
        }
    }

    function init() {
        let vSource = document.getElementById("vertexSource").text;
        let fSource = document.getElementById("fragmentSource").text;
        let vertexShader = createShader(gl.VERTEX_SHADER,vSource);
        let fragmentShader = createShader(gl.FRAGMENT_SHADER,fSource);
        let program = createProgram(vertexShader,fragmentShader);
        gl.useProgram(program);
        depthLoc = gl.getUniformLocation(program,"depth");
        offsetLoc = gl.getUniformLocation(program,"offset");
        colorLoc = gl.getUniformLocation(program,"color");
        alphaLoc = gl.getUniformLocation(program,"alpha");
        coordLoc = gl.getAttribLocation(program,"coordinates");
        console.log(depthLoc,offsetLoc,colorLoc,alphaLoc,colorLoc);
        gl.enableVertexAttribArray(coordLoc);
        ballCoordBuffer = gl.createBuffer();
        platformCoordBuffer = gl.createBuffer();
        midlineBuffer = gl.createBuffer();
        gl.clearColor(0.0,0.0,0.0,1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);
        gl.viewport(0,0,canvas.width,canvas.height);

        let vertices = [
            platformHeight/2,platformWidth/2,
            -platformHeight/2,platformWidth/2,
            platformHeight/2,-platformWidth/2,
            -platformHeight/2,-platformWidth/2
        ];
        gl.bindBuffer(gl.ARRAY_BUFFER,platformCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER,ballCoordBuffer);
        vertices = [
            ballSize/2,ballSize/2,
            ballSize/2,-ballSize/2,
            -ballSize/2,ballSize/2,
            -ballSize/2,-ballSize/2
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);

        gl.bindBuffer(gl.ARRAY_BUFFER,midlineBuffer);
        vertices = [
            -midlineWidth/2,1.0,
            midlineWidth/2,1.0,
            -midlineWidth/2,-1.0,
            midlineWidth/2,-1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);

        zero.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,zero.buffer);
        vertices = [
            0.0,numberHeight,
            numberWidth/3,numberHeight*4/5,
            numberWidth,numberHeight,
            numberWidth*2/3,numberHeight*4/5,
            numberWidth,0.0,
            numberWidth*2/3,numberHeight/5,
            0.0,0.0,
            numberWidth/3,numberHeight/5,
            0.0,numberHeight,
            numberWidth/3,numberHeight*4/5
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
        zero.length = vertices.length/2;

        one.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,one.buffer);
        vertices = [
            numberWidth*2/3,numberHeight,
            numberWidth,numberHeight,
            numberWidth*2/3,0.0,
            numberWidth,0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
        one.length = vertices.length/2;


        two.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,two.buffer);
        vertices = [
            0.0,numberHeight,
            0.0,numberHeight*4/5,
            numberWidth,numberHeight,
            numberWidth*2/3,numberHeight*4/5,
            numberWidth,numberHeight*2/5,
            numberWidth*2/3,numberHeight*3/5,
            numberWidth/3,numberHeight*2/5,
            0.0,numberHeight*3/5,
            numberWidth/3,numberHeight/5,
            0.0,0.0,
            numberWidth,numberHeight/5,
            numberWidth,0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
        two.length = vertices.length/2;

        three.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,three.buffer);
        vertices = [
            0.0,numberHeight,
            0.0,numberHeight*4/5,
            numberWidth,numberHeight,
            numberWidth*2/3,numberHeight*4/5,
            numberWidth,numberHeight*3/5,
            numberWidth*2/3,numberHeight*2/5,
            0.0,numberHeight*3/5,
            0.0,numberHeight*2/5,
            numberWidth*2/3,numberHeight*3/5,
            numberWidth,numberHeight*2/5,
            numberWidth,numberHeight*3/5,
            numberWidth,numberHeight*2/5,
            numberWidth*2/3,numberHeight/5,
            numberWidth,0.0,
            0.0,0.0,
            0.0,numberHeight/5,
            numberWidth*2/3,numberHeight/5
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
        three.length = vertices.length/2;

        four.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER,four.buffer);
        vertices = [
            numberWidth/3,numberHeight,
            0.0,numberHeight,
            numberWidth/3,numberHeight*3/5,
            0.0,numberHeight*2/5,
            numberWidth*2/3,numberHeight*2/5,
            numberWidth*2/3,numberHeight*3/5,
            numberWidth,numberHeight*3/5,
            numberWidth,0.0,
            numberWidth*2/3,0.0,
            numberWidth,numberHeight,
            numberWidth*2/3,numberHeight
        ];
        gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);
        four.length = vertices.length/2;




        gl.bindBuffer(gl.ARRAY_BUFFER,null);

        draw();

        window.onkeydown = onKeyDown;
        window.onkeyup = onKeyUp;
    }

    window.onload = init;
</script>
</body>
</html>